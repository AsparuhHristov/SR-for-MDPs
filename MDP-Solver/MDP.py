# -*- coding: utf-8 -*-
"""
Created on Tue Jun 27 09:38:32 2017

@author: hristov
"""

import numpy as np

"""
Examples:

Generate train test:
params = SetParams(M=150,N=50,c1=1,c2=1,lam=3,mu1=5,a=0.6,b=0.01)
X,Y,gmax=GenerateTrainTest(params)
X_train=np.concatenate((X_train,X),axis=0)
y_train=np.concatenate((y_train,Y),axis=0)
gmax_train=(gmax_train,gmax)

Optimal one full circle:
params = SetParams(M=200,N=50,c1=1,c2=1,lam=1,mu1=5,a=0.4,b=0.1)
f,newV,gMax = MDPSolver(params)
thresholdsOriginal=GeneratorThresholds(params,func=f)
functionOriginal=ComposeF(thresholdsOriginal,bounds=(params[0],params[1]))
f,newV,gMax = MDPSolver(params,f=functionOriginal)

Optimal one bounded (resized):
params = SetParams(M=200,N=50,c1=1,c2=1,lam=1,mu1=5,a=0.4,b=0.1)
f,newV,gMax = MDPSolver(params)
thresholdsOriginal=GeneratorThresholds(params,func=f)
functionOriginalResized=ComposeF(thresholdsOriginal)
params = SetParams(M=50,N=30,c1=1,c2=1,lam=1,mu1=5,a=0.4,b=0.1)
f,newV,gMax = MDPSolver(params,f=functionOriginalResized)

Predicted one:
params = SetParams(M=50,N=30,c1=1,c2=1,lam=1,mu1=5,a=0.4,b=0.1)
functionPredicted=ComposeF(pred_tresh)
f,newV,gMax = MDPSolver(params,f=functionPredicted)

Static one:
params = SetParams(M=200,N=50,c1=1,c2=1,lam=1,mu1=5,a=0.4,b=0.1)
f,newV,gMax = MDPSolver(params,f=StaticF(M=params[0],N=params[1],k=3))

Generated by a function:
params = SetParams(M=200,N=50,c1=1,c2=1,lam=1,mu1=5,a=0.4,b=0.1)
f,newV,gMax = MDPSolver(params,f=ComposeF(params,func=SimpleFunc))
"""

def MDPSolver(params,precision=0.1**10,f=0):
    (M,N,c1,c2,lam,mu1,a,b)=params
    oldV=np.zeros((M+1,N+1))
    gMax,gMin=precision+1,0
    if type(f)==int and f==0:
        while gMax-gMin>=precision:
            f,newV,gMax,gMin=OneStepImprovement(params,oldV)
            oldV=newV
    else:
        if NotValidF(f,M,N):
            f=np.ones((M+1,N+1))*2
        while gMax-gMin>=precision:
            f,newV,gMax,gMin=OneStepNoImprovement(params,oldV,f)
            oldV=newV  
    return f,newV,gMax
    
def OneStepImprovement(params,oldV):
#    Initialize the variables
    (M,N,c1,c2,lam,mu1,a,b)=params
    f=np.zeros((M+1,N+1))
    newV=np.zeros((M+1,N+1))
    sumRate1=lam+mu1
    
#    Case of 0<=x2<=N-1
    for x2 in range(N):
        mu2=1/(a+x2*b)
        sumRate2=lam+mu2
        for x1 in range(M+1):
            
            option1=(c1*x1+c2*x2+lam*oldV[min(x1+1,M),x2]+mu1*oldV[max(x1-1,0),x2+1])/sumRate1
            option2=(c1*x1+c2*x2+lam*oldV[min(x1+1,M),x2]+mu2*oldV[x1,0])/sumRate2
            
            if option1<=option2:
                newV[x1,x2],f[x1,x2]=option1,1
            else:
                newV[x1,x2],f[x1,x2]=option2,2
                
#    Case of x2=N
    mu2=1/(a+N*b)
    sumRate2=lam+mu2
    for x1 in range(M+1):
        newV[x1,N],f[x1,N]=(c1*x1+c2*N+lam*oldV[min(x1+1,M),N]+mu2*oldV[x1,0])/sumRate2,2
    
    gMax,gMin=max(np.max(newV-oldV,axis=0)),min(np.min(newV-oldV,axis=0))
    return f,newV,gMax,gMin
    
def OneStepNoImprovement(params,oldV,f):
#    Initialize the variables
    (M,N,c1,c2,lam,mu1,a,b)=params
    newV=np.zeros((M+1,N+1))
    sumRate1=lam+mu1
    f[:,N]=f[:,N]*0+2
    
#    Case of 0<=x2<=N-1
    for x2 in range(N+1):
        mu2=1/(a+x2*b)
        sumRate2=lam+mu2
        for x1 in range(M+1):
            if f[x1,x2]==1:
                newV[x1,x2]=(c1*x1+c2*x2+lam*oldV[min(x1+1,M),x2]+mu1*oldV[max(x1-1,0),x2+1])/sumRate1
            else:
                newV[x1,x2]=(c1*x1+c2*x2+lam*oldV[min(x1+1,M),x2]+mu2*oldV[x1,0])/sumRate2
                
    gMax,gMin=max(np.max(newV-oldV,axis=0)),min(np.min(newV-oldV,axis=0))
    
    return f,newV,gMax,gMin
   
def ComposeF(thresholds,bounds=(50,30)):
    f=np.zeros((bounds[0]+1,bounds[1]+1))
    for i in range(bounds[0]+1):
        thres=np.clip(int(thresholds[i]),0,bounds[1])
        f[i,:thres],f[i,thres:]=1,2
    return f

def GeneratorThresholds(params,func):
    (M,N,c1,c2,lam,mu1,a,b)=params
    thresholds=[]
    if NotValidF(func,M,N):
        for i in range(M+1):
            thresholds.append(np.clip(func(i,params),0,N))
    else:
        for i in range(M+1):
            thresholds.append(np.clip(np.nonzero(func[i,:] == 2)[0][0],0,N))   
    return thresholds
     
def StaticF(M,N,k):
    return np.concatenate((np.ones((M+1,k)),np.ones((M+1,N+1-k))*2),axis=1)

def NotValidF(f,M,N):
    return type(f)!=np.ndarray or f.shape!=(M+1,N+1) or max(np.max(f,axis=0))>2 or min(np.min(f,axis=0))<1

def SetParams(M,N,c1,c2,lam,mu1,a,b):
    return (M,N,c1,c2,lam,mu1,a,b)
    
def SimpleFunc(i,params):
    if i<20:
        return -2
    else:
        return 1000
    
def GenerateTrainTest(params,bounds=(50,30)):
    (M,N,c1,c2,lam,mu1,a,b)=params
    X=np.zeros((bounds[0]+1,len(params)-1))
    Y=np.zeros((bounds[0]+1,1))
    f,newV,gMax = MDPSolver(params)
    thresholds=GeneratorThresholds(params,func=f)
    for i in range(bounds[0]+1):
        X[i]=(c1,c2,lam,mu1,a,b,i)
        Y[i]=min(thresholds[i],bounds[1])
    return X,Y,gMax
